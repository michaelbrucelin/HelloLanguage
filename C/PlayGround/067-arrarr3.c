#include <stdio.h>

int main(void)
{
    char board[3][3] = {
        {'1', '2', '3'},
        {'4', '5', '6'},
        //{'4', 'X', '6'},
        {'7', '8', '9'}};

    //*board是二维数组第一个元素（数组）的地址，即真正意义上第一个元素的地址，所以可以正确打印所有元素
    //board是board[0]的地址，*board是board[0]的值，即board[0][0]的地址，所以*board+i就是board[0][i]的地址
    printf("1: *(*board + i)\n");
    for (int i = 0; i < 9; i++)
        printf("[%d]: {%c:%p}\t", i, *(*board + i), *(*board + i));
    printf("\n\n");

    //board是二维数组的地址，即二维数组第一个元素（数组）的地址，并不是真正元素的地址
    //同理，board+i就是二维数组第i+1个元素（数组）的地址
    //所以这时取值取的是二维数组的元素（数组）的值，不一定会打印出什么东西
    //board是board[0]的地址，board+i是board[i]的地址，一次取值取的是一维数组的地址，而且还超出了二维数组的长度
    printf("2: *(board + i)\n");
    for (int i = 0; i < 9; i++)
        printf("[%d]: {%c:%p}\t", i, *(board + i), *(board + i));
    printf("\n\n");

    //board是二维数组的地址，即二维数组第一个元素（数组）的地址，并不是真正元素的地址
    //同理，board+i就是二维数组第i+1个元素（数组）的地址
    //由于这里连续2次取值，第1次取到的是二维数组的元素（数组）的值，第2次取到的就是一维数组第一个元素的值
    //所以前3次打印分别为二维数组每个元素（数组）的第一个元素的值，从第4次开始，就不一定会打印出什么东西了
    //board是board[0]的地址，board+i是board[i]的地址，两次取值可以取到元素的值，只是地址不对
    printf("3: **(board + i)\n");
    for (int i = 0; i < 9; i++)
        printf("[%d]: {%c:%p}\t", i, **(board + i), **(board + i));
    printf("\n\n");

    //**board是二维数组的第一个元素（数组）的第一个元素的值
    //看起来像是打印出了正确的结果，但是是假象，将数组中某个元素改为一个字母，再次编译执行就看到了
    //**board就是board[0][0]
    printf("4: **board + i\n");
    for (int i = 0; i < 9; i++)
        printf("[%d]: {%c:%p}\t", i, **board + i, **board + i);
    printf("\n\n");

    return 0;
}

/*
//加入打印指针后的输出
./a.out 
1: *(*board + i)
[0]: {1:0x31}   [1]: {2:0x32}   [2]: {3:0x33}   [3]: {4:0x34}   [4]: {5:0x35}   [5]: {6:0x36}   [6]: {7:0x37}   [7]: {8:0x38}   [8]: {9:0x39}

2: *(board + i)
[0]: {G:0x7ffd743d9747} [1]: {J:0x7ffd743d974a} [2]: {M:0x7ffd743d974d} [3]: {P:0x7ffd743d9750} [4]: {S:0x7ffd743d9753} [5]: {V:0x7ffd743d9756} [6]: {Y:0x7ffd743d9759} [7]: {\:0x7ffd743d975c} [8]: {_:0x7ffd743d975f}

3: **(board + i)
[0]: {1:0x31}   [1]: {4:0x34}   [2]: {7:0x37}   [3]: {@:0x40}   [4]: {t:0x74}   [5]: {:(nil)}   [6]: {:(nil)}   [7]: {  :0x9}   [8]: {:(nil)}

4: **board + i
[0]: {1:0x31}   [1]: {2:0x32}   [2]: {3:0x33}   [3]: {4:0x34}   [4]: {5:0x35}   [5]: {6:0x36}   [6]: {7:0x37}   [7]: {8:0x38}   [8]: {9:0x39}

//没有加入打印指针时的输出
./a.out 
1: *(*board + i)
[0]: 1  [1]: 2  [2]: 3  [3]: 4  [4]: 5  [5]: 6  [6]: 7  [7]: 8  [8]: 9

2: *(board + i)
[0]: G  [1]: J  [2]: M  [3]: P  [4]: S  [5]: V  [6]: Y  [7]: \  [8]: _

3: **(board + i)
[0]: 1  [1]: 4  [2]: 7  [3]: @  [4]:    [5]:    [6]:    [7]:            [8]: 

4: **board + i
[0]: 1  [1]: 2  [2]: 3  [3]: 4  [4]: 5  [5]: 6  [6]: 7  [7]: 8  [8]: 9

将数组的第四项改为X后重新编译执行
./a.out 
1: *(*board + i)
[0]: 1  [1]: 2  [2]: 3  [3]: 4  [4]: X  [5]: 6  [6]: 7  [7]: 8  [8]: 9

2: *(board + i)
[0]:   [1]:   [2]:    [3]:    [4]: #  [5]: &  [6]: )  [7]: ,  [8]: /

3: **(board + i)
[0]: 1  [1]: 4  [2]: 7  [3]:   [4]: )  [5]:    [6]:    [7]:            [8]: 

4: **board + i
[0]: 1  [1]: 2  [2]: 3  [3]: 4  [4]: 5  [5]: 6  [6]: 7  [7]: 8  [8]: 9
*/