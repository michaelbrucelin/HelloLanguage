#include <stdio.h>

/*
在实际项目中，很多时候&和|都是和>>、<<配合使用的。
比如在蓝牙项目开发中，2个设备之间进行日期数据传输时，我们先定一个协议，用4个byte来表示一个日期，其中byte0表示年份的高位数，byte1表示年份的低位数，byte2表示月份，byte3表示日期。
设备端现在收到另外一台设备传过来的日期数据00010100 00010011 00001010 00011000（为了阅读方便我将每个byte之间用空格分开）。那么我要如何解析这个数据来得到实际日期呢？
*/

int main(void)
{
    unsigned int date, day, month, year_low, year_high;

    /* 
    *第一步，获取日期。
    *日期是最后一个byte，也就是最后8位，用一个后8位是1其余位是0的数(11111111，十六进制表示是0xFF)与数据进行按位与计算即可
    */
    date = 0b00010100000100110000101000011000; //初始值为00010100 00010011 00001010 00011000
    day = date & 0xFF;                         //计算结果是00011000，十进制表示是24，也就是日期是24

    /* 
    *第二步，获取月份。
    *月份是倒数第2个byte，此时需要先将最后一个byte砍掉(也就是右移8位)，然后再和0xFF进行按位与运算
    *下面代码可以简写成date=date>>8&0xff;
    */
    date = date >> 8;    //计算结果是00010100 00010011 00001010
    month = date & 0xFF; //计算结果是00001010，十进制表示是10，也就是月份是10月

    /* 
    *第三步，获取年份低位。
    *先将最后一个byte砍掉(也就是右移8位)，然后再和0xFF进行按位与运算
    *下面代码可以简写成date=date>>8&0xff;
    */
    date = date >> 8;       //计算结果是00010100 00010011
    year_low = date & 0xFF; //计算结果是00010011，十进制表示是19

    /* 
    *第四步，获取年份高位。
    *先将最后一个byte砍掉(也就是右移8位)，然后再和0xFF进行按位与运算
    *下面代码可以简写成date=date>>8&0xff;
    */
    date = date >> 8;        //计算结果是00010100
    year_high = date & 0xFF; //计算结果是00010011，十进制表示是20

    printf("date is %02d%02d%02d%02d.\n", year_high, year_low, month, day);
}