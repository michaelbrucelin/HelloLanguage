# 1. 嵌套列表，二(n)维列表
import copy
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
matrix = [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]

print(matrix[1][1])

for i in matrix:
    for j in i:
        print(j, end=' ')
    print()

# 2. 嵌套列表的一个“高级”错误
A = [0] * 3  # A [0, 0, 0]
for i in range(3):
    A[i] = [0] * 3  # A [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

B = [[0] * 3] * 3   # B [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

print("A: ", A)
print("B: ", B)
# 目前为止，看起来两种方式创建的嵌套列表是一样的，其实不然，B是“错误”的
A[1][1] = 1  # A [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
B[1][1] = 1  # B [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
print("A: ", A)
print("B: ", B)
# 导致B“结果异常”的原因很简单，与C的指针还有C#的引用类型是一个道理
print("A[0] is A[1]: ", A[0] is A[1])
print("B[0] is B[1]: ", B[0] is B[1])

# 3. 不是拷贝，只是改变引用
x = [1, 2, 3]
y = x
x[1] = 0
print(y)  # y也被改为[1, 0, 3]，因为=只是做了引用关联，并不是拷贝

# 4. 浅拷贝
nums = list(range(10))
nums_copy1 = nums.copy()
nums_copy2 = nums[:]

x = [1, 2, 3]
y = x.copy()  # 或 y = x[:] 也是一样的，都是浅拷贝
x[1] = 0
print(y)  # y的值被没有被更改
# 上面看似没有问题，但是与C#的浅拷贝是一样的
# 当拷贝的复杂对象时（例如嵌套列表），外部的对象是拷贝了一个对象，但是内部的对象拷贝的是一个引用
x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
y = x.copy()    # 或 y = x[:] 也是一样的，都是浅拷贝
x[1][1] = 0
print(y)  # y的值也被更改

# 5. 深拷贝
x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
y = copy.copy(x)  # 注意，这个方法仍然是浅拷贝
x[1][1] = 0
print(y)  # y的值也被更改

x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
y = copy.deepcopy(x)  # 注意，这个方法才是深拷贝
x[1][1] = 0
print(y)  # y的值没有被更改
