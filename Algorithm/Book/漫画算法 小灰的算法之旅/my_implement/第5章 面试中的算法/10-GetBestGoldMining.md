# 金矿问题

动态规划的两大要素：

> 1. 问题的初始状态
> 2. 问题的状态转移方程

## 问题

很久很久以前，有一位国王拥有5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人人数也不同。
例如有的金矿储量是500kg黄金，需要5个工人来挖掘；有的金矿储量是200kg黄金，需要3个工人来挖掘……
如果参与挖矿的工人的总数是10。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半的金矿。
要求用程序求出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

### 分析1

我们把金矿数量设为n，工人数量设为w，金矿的含金量设为数组g\[\]，金矿所需开采人数设为数组p\[\]，设F(n, w)为n个金矿、w个工人时的最优收益函数为：F(n, w)

**1. 初始状态：**

> F(n, w) = 0 (n=0 或 w=0)

**2. 状态转移方程：**

假设金矿数量n-1，工人数量w时，已知最大收益为F(n-1, w)，那么F(n, w)，即增加了一个金矿g[n]，需要的人数为p[n]

- 如果不开采g[n]，则 F(n, w) = F(n-1, w)
- 如果开采g[n]，则 F(n, w) = g[n] + F(n-1, w-p[n])

所以状态转移方程为：

> $F(n, w) = MAX(F(n-1, w), g[n] + F(n-1, w-p[n]))$

**3. 示例1：**

例如，共有10人，5座金矿，分别为：(200kg, 3人)，(300kg, 4人)，(350kg, 3人)，(400kg, 5人)，(500kg, 5人)。

|  | 0座矿 | (200kg, 3人) | (300kg, 4人) | (350kg, 3人) | (400kg, 5人) | (500kg, 5人) |
| -- | -- | -- | -- | -- | -- | -- |
|  **0人** | 0 |   0 |   0 |   0 |   0 |   0 |
|  **1人** | 0 |   0 |   0 |   0 |   0 |   0 |
|  **2人** | 0 |   0 |   0 |   0 |   0 |   0 |
|  **3人** | 0 | 200 | 200 | 350 | 350 | 350 |
|  **4人** | 0 | 200 | 300 | 350 | 350 | 350 |
|  **5人** | 0 | 200 | 300 | 350 | 400 | 500 |
|  **6人** | 0 | 200 | 300 | 550 | 550 | 550 |
|  **7人** | 0 | 200 | 500 | 650 | 650 | 650 |
|  **8人** | 0 | 200 | 500 | 650 | 750 | 850 |
|  **9人** | 0 | 200 | 500 | 650 | 750 | 850 |
| **10人** | 0 | 200 | 500 | 850 | 850 | 900 |

```csharp
public static void Main(string[] args)
{
    (int mine, int worker)[] mines = new (int mine, int worker)[] { (0, 0), (200, 3), (300, 4), (350, 3), (400, 5), (500, 5) };

    int[,] buffer = new int[11, 6];
    for (int w = 1; w < buffer.GetLength(0); w++)
    {
        for (int n = 1; n < buffer.GetLength(1); n++)
        {
            // F(n, w) = MAX(F(n-1, w), g[n] + F(n-1, w-p[n]))
            if (w < mines[n].worker)
                buffer[w, n] = buffer[w, n - 1];
            else
                buffer[w, n] = Math.Max(buffer[w, n - 1], mines[n].mine + buffer[w - mines[n].worker, n - 1]);
        }
    }

    for (int i = 0; i < buffer.GetLength(0); i++)
    {
        for (int j = 0; j < buffer.GetLength(1); j++)
            Console.Write($"{buffer[i, j]}\t");
        Console.WriteLine();
    }
}
```

**4. 示例2：**

例如，共有10人，5座金矿，分别为：(200kg, 3人)，(300kg, 4人)，(350kg, 3人)，(400kg, 5人)，(500kg, 5人)。
**这样理解在编程上更好一点，可以看到下面二维数组的推导过程中，每个值的推导，都仅用到上一行的值，所以真正编写代码的时候，可以将下面的二维数组改为一维数组，来降低算法的空间复杂度。**

|  | 0人 | 1人 | 2人 | 3人 | 4人 | 5人 | 6人 | 7人 | 8人 | 9人 | 10人 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| **(0kg, 0人)** | 0 | 0 | 0 |   0 |   0 |   0 |   0 |   0 |   0 |   0 |   0 |
| **(200kg, 3人)** | 0 | 0 | 0 | 200 | 200 | 200 | 200 | 200 | 200 | 200 | 200 |
| **(300kg, 4人)** | 0 | 0 | 0 | 200 | 300 | 300 | 300 | 500 | 500 | 500 | 500 |
| **(350kg, 3人)** | 0 | 0 | 0 | 350 | 350 | 350 | 550 | 650 | 650 | 650 | 850 |
| **(400kg, 5人)** | 0 | 0 | 0 | 350 | 350 | 400 | 550 | 650 | 750 | 750 | 850 |
| **(500kg, 5人)** | 0 | 0 | 0 | 350 | 350 | 500 | 550 | 650 | 850 | 850 | 900 |

```csharp
public static void Main(string[] args)
{
    (int mine, int worker)[] mines = new (int mine, int worker)[] { (0, 0), (200, 3), (300, 4), (350, 3), (400, 5), (500, 5) };

    int[,] buffer = new int[6, 11];
    for (int n = 1; n < buffer.GetLength(0); n++)
    {
        for (int w = 1; w < buffer.GetLength(1); w++)
        {
            // F(n, w) = MAX(F(n-1, w), g[n] + F(n-1, w-p[n]))
            if (w < mines[n].worker)
                buffer[n, w] = buffer[n - 1, w];
            else
                buffer[n, w] = Math.Max(buffer[n - 1, w], mines[n].mine + buffer[n - 1, w - mines[n].worker]);
        }
    }

    for (int i = 0; i < buffer.GetLength(0); i++)
    {
        for (int j = 0; j < buffer.GetLength(1); j++)
            Console.Write($"{buffer[i, j]}\t");
        Console.WriteLine();
    }
}
```
