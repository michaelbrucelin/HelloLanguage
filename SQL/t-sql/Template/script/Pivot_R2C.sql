-- 数据透视，行转列
-- 数据透视是一种通过聚合和旋转把数据行转换成数据列的技术。当透视数据时，需要确定3个要素：要在行（分组元素）中看到的元素，要在列（扩展元素）中看到的元素，要在数据部分（聚合元素）看到的元素。

-- 测试数据
create table #temp([name] nvarchar(16), [period] nvarchar(16), course nvarchar(16), score int)
insert into #temp([name], [period], course, score)
values   ('天雄星',  '第一学期', '数学', 90)
       , ('天雄星',  '第一学期', '语文', 40)
       , ('天雄星',  '第一学期', '语文', 50)
       , ('天雄星',  '第一学期', '语文', 60)
       , ('天雄星',  '第一学期', '音乐', 80)
       , ('贝多芬',  '第一学期', '数学', 70)
       , ('贝多芬',  '第一学期', '语文', 88)
       , ('贝多芬',  '第一学期', '音乐', 100)
       , ('大仲马',  '第一学期', '数学', 60)
       , ('大仲马',  '第一学期', '语文', 100)
       , ('大仲马',  '第一学期', '音乐', 75)
       , ('爱因斯坦','第一学期', '数学', 100)
       , ('爱因斯坦','第一学期', '语文', 60)
       , ('爱因斯坦','第一学期', '音乐', 85)
       , ('天雄星',  '第二学期', '语文', 40)
       , ('天雄星',  '第二学期', '语文', 50)
       , ('天雄星',  '第二学期', '语文', 60)
       , ('天雄星',  '第二学期', '音乐', 80)
       , ('贝多芬',  '第二学期', '数学', 70)
       , ('贝多芬',  '第二学期', '语文', 88)
       , ('贝多芬',  '第二学期', '音乐', 100)
       , ('大仲马',  '第二学期', '数学', 60)
       , ('大仲马',  '第二学期', '语文', 100)
       , ('大仲马',  '第二学期', '音乐', 75)
       , ('爱因斯坦','第二学期', '数学', 100)
       , ('爱因斯坦','第二学期', '语文', 60)
       , ('爱因斯坦','第二学期', '音乐', 85)

-- 解决方案1
select * from #temp pivot(max(score) for course in (数学,语文,音乐)) as pt
--将for后面接的列（course）分成更多的列，具体分成哪些列，由in后面接的选项（数学,语文,音乐）决定，选项为原列（course）中的有效值的子集；
--拆分出来的列（数学,语文,音乐）的值是for前面的聚集函数决定（max(score)）
--表的整体相当于
--    根据除“被拆分列（course）”和“值列（score）”外的所有列做了分组（group by），分组后的值为行
--    根据“被拆分列（course）”的值，生成新的列
--    根据“值列（score）”与聚合函数形成透视区域的值

-- 解决方案2
select [name], [period]
       , MAX(case course when '数学' then score else 0 end) as 数学
       , MAX(case course when '语文' then score else 0 end) as 语文
       , MAX(case course when '音乐' then score else 0 end) as 音乐
from #temp
group by name, period
