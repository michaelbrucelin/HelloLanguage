--[[
closure（闭包，闭合函数）
若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这项特征称为“词法域”。
--]]

function myCounter()
    local i = 0        -- i 是外部函数myCounter的局部变量
    return function()  -- 匿名函数
        i = i + 1      -- 在匿名函数内，i 既不是全局变量，也不是局部变量，而是将其称为“非局部变量（non-local variable）”
                       -- 由于一些历史原因，在lua中“非局部变量”也称为upvalue
        return i
    end
end

c1 = myCounter()
print("c1", c1())  --> 1
print("c1", c1())  --> 2

--[[
上面的代码中，匿名函数访问了一个“非局部变量” i，该变量用于保持一个计数器。
初看上去，由于创建 i 的函数（myCounter）已经返回，所以之后每次调用匿名函数时，i 都应该是超出作用范围的，但其实不然，lua会以closure的概念来正确的处理这种情况。
简单的讲，一个closure就是一个函数加上该函数所需访问的所有“非局部变量”。
如果再次调用myCounter，那么它就会创建一个新的局部变量 i，从而也将得到一个新的closure。
所以c1和c2是同一个函数所创建的两个不同的closure，它们各自拥有局部变量 i 的独立实例。

--------> 感觉就是一个简易版的类呢，局部变量是类的字段，只允许类的方法（此处的匿名函数）更新值，对外可访问 <--------
--]]

c2 = myCounter()
print("c2", c2())  --> 1
print("c1", c1())  --> 3
print("c2", c2())  --> 2

--[[
lua depinfunc2.lua
> c1      1
> c1      2
> c2      1
> c1      3
> c2      2
--]]