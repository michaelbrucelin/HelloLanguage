**方法一：贪心 + 正向思维**

我们把数组中的数分成三部分 `a`，`b` 和 `c`，它们分别包含所有被 `3` 除余 `0`，`1`，`2` 的数。显然，我们可以选取 `a` 中所有的数，而对于 `b` 和 `c` 中的数，我们需要根据不同的情况选取不同数量的数。

假设我们在 `b` 中选取了 `j0` 个数，`c` 中选取了 `k0` 个数，那么这些数的和被 `3` 除的余数为 `(j0 + 2k0) % 3 = (j0 - k0) % 3`。由于所有选出的数的和必须为 `3` 的倍数，因此 `j0 - k0` 必须也为 `3` 的倍数，即 `j0` 和 `k0` 模 `3` 同余。而我们又可以发现，如果我们在 `b` 中选取了 `j0` 个数，并且 `j0 + 3 <= |b|`，其中 `|b|` 表示 `b` 中数的个数，那么我们可以从 `b` 中再选取额外的 `3` 个数，既能保证 `(j0 - k0) % 3 == 0` 仍然成立，也能使得答案更优。

因此我们可以发现，我们在 `b` 中一定会选取 `|b| - 2`，`|b| - 1` 或 `|b|` 个数。同理，我们在 `c` 中一定会选取 `|c| - 2`，`|c| - 1` 或 `|c|` 个数。因此我们只需要使用两重循环，枚举最多 `3 * 3 = 9` 种情况。在从 `b` 或 `c` 中选取数时，我们可以贪心地从大到小选取数，因此需要在这之前对 `b` 和 `c` 进行排序。

```Python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        a = [x for x in nums if x % 3 == 0]
        b = sorted([x for x in nums if x % 3 == 1], reverse=True)
        c = sorted([x for x in nums if x % 3 == 2], reverse=True)

        ans = 0
        lb, lc = len(b), len(c)
        for j0 in [lb - 2, lb - 1, lb]:
            if j0 >= 0:
                for k0 in [lc - 2, lc - 1, lc]:
                    if k0 >= 0 and j0 % 3 == k0 % 3:
                        ans = max(ans, sum(b[:j0]) + sum(c[:k0]))
        return ans + sum(a)

```

**复杂度分析**

-   时间复杂度：O(Nlog⁡N)，其中 N 是数组 `nums` 的长度。在平均情况下，数组 `b` 和 `c` 的长度规模与 `nums` 相当，因此可以用 O(Nlog⁡N) 近似将 `b` 和 `c` 进行排序的时间复杂度。

-   空间复杂度：O(N)。


**方法二：贪心 + 逆向思维**

在方法一中，我们用的是一种 “正向思维”，即枚举 `b` 和 `c` 中分别选出了多少个数。我们同样也可以使用一种逆向思维，枚举 `b` 和 `c` 中分别丢弃了多少个数。

我们设 `tot` 为数组 `nums` 中所有元素的和，此时 `tot` 会有三种情况：

-   `tot` 是 `3` 的倍数，那么我们不需要丢弃任何数；
    
-   `tot` 模 `3` 余 `1`，此时我们有两种选择：要么丢弃 `b` 中最小的 `1` 个数，要么丢弃 `c` 中最小的 `2` 个数；
    
-   `tot` 模 `3` 余 `2`，此时我们有两种选择：要么丢弃 `b` 中最小的 `2` 个数，要么丢弃 `c` 中最小的 `1` 个数。
    

在这种方法中，我们同样可以对 `b` 和 `c` 进行排序后，根据 `tot` 的情况来选出 `b` 或 `c` 中最小的 `1` 或 `2` 个数。下面的代码中使用的就是排序后再选出数的方法。我们也可以不用排序，直接对 `b` 和 `c` 进行扫描选出最小的 `2` 个数，随后根据 `tot` 的情况选出若干个数并丢弃，这样就省去了排序的时间复杂度。

```Python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        a = [x for x in nums if x % 3 == 0]
        b = sorted([x for x in nums if x % 3 == 1], reverse=True)
        c = sorted([x for x in nums if x % 3 == 2], reverse=True)
        tot = sum(nums)
        ans = 0

        if tot % 3 == 0:
            ans = tot
        if tot % 3 == 1:
            if len(b) >= 1:
                ans = max(ans, tot - b[-1])
            if len(c) >= 2:
                ans = max(ans, tot - sum(c[-2:]))
        elif tot % 3 == 2:
            if len(b) >= 2:
                ans = max(ans, tot - sum(b[-2:]))
            if len(c) >= 1:
                ans = max(ans, tot - c[-1])

        return ans

```

**复杂度分析**

-   时间复杂度：O(Nlog⁡N)，其中 N 是数组 `nums` 的长度。也可以不用排序，将时间复杂度优化至 O(N)。

-   空间复杂度：O(N)。也可以不用排序，将时间复杂度优化至 O(1)。


**方法三：动态规划**

在上面的两种方法中，我们都是基于贪心的思路，要么选择若干个较大的数，要么丢弃若干个较小的数。我们也可以使用动态规划的方法，不需要进行排序或者贪心，直接借助状态转移方程得出解。

我们用 `f[i][j]` 表示前 `i` 个数中选取了若干个数，并且它们的和模 `3` 余 `j` 时，这些数的和的最大值。那么对于当前的数 `nums[i]`，如果我们选取它，那么就可以通过 `f[i - 1][j0]` 转移得来，其中 `(j0 + nums[i]) % 3 == j % 3`；如果我们不选取它，就可以通过 `f[i - 1][j]` 转移得来。因此我们可以写出如下的状态转移方程：

```
f[i][j] = max(f[i - 1][j], f[i - 1][(j - nums[i]) % 3] + nums[i])
f[0][0] = 0
f[0][i] = N/A

```

由于 `(j - nums[i]) % 3` 可能会引入负数，因此这道题用递推的形式来实现动态规划较为方便：

```
f[i - 1][j] -> f[i][j]
f[i - 1][j] + nums[i] -> f[i][(j + nums[i]) % 3]
f[0][0] = 0
f[0][i] = N/A

```

我们还可以发现，所有的 `f[i][..]` 只会从 `f[i - 1][..]` 转移得来，因此我们在动态规划时只存储这两行的结果，减少空间复杂度。

```Python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        f = [0, -1, -1]
        for num in nums:
            g = f[:]
            for i in range(3):
                if f[i] != -1:
                    g[(i + num % 3) % 3] = max(g[(i + num % 3) % 3], f[i] + num)
            f = g
        return f[0]

```

**复杂度分析**

-   时间复杂度：O(N)。

-   空间复杂度：O(1)。
