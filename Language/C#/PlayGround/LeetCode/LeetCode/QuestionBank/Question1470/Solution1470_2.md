这个问题空间复杂度是 O(n) 的解法太简单了，不多说了。说说空间复杂度为 O(1) 的做法，原地完成：）

实际上，有两个思路可以完成这一点。

以下解析可能结合代码看会更好理解。

  

**思路一**

因为题目限制了每一个元素 nums[i] 最大只有可能是 1000，这就意味着每一个元素只占据了 10 个 bit。（2^10 - 1 = 1023 > 1000）

而一个 int 有 32 个 bit，所以我们还可以使用剩下的 22 个 bit 做存储。实际上，每个 int，我们再借 10 个 bit 用就好了。

因此，在下面的代码中，每一个 nums[i] 的最低的十个 bit（0-9 位），我们用来存储原来 nums[i] 的数字；再往前的十个 bit（10-19 位），我们用来存储重新排列后正确的数字是什么。

在循环中，我们每次首先计算 nums[i] 对应的重新排列后的索引 j，之后，取 nums[i] 的低 10 位（`nums[i] & 1023`），即 nums[i] 的原始信息，把他放到 nums[j] 的高十位上。

最后，每个元素都取高 10 位的信息(`e >> 10`)，即是答案。

我的参考代码（C++）：

```
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {

        for(int i = 0; i < 2 * n; i ++){
            int j = i < n ? 2 * i : 2 * (i - n) + 1;
            nums[j] |= (nums[i] & 1023) << 10;
        }
        for(int& e: nums) e >>= 10;
        return nums;
    }
};

```
