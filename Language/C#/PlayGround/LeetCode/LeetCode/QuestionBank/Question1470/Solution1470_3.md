这个问题空间复杂度是 O(n) 的解法太简单了，不多说了。说说空间复杂度为 O(1) 的做法，原地完成：）

实际上，有两个思路可以完成这一点。

以下解析可能结合代码看会更好理解。

**思路二**

利用题目中限制每一个元素 nums\[i\] 都大于 0。我们可以使用负数做标记。

标记什么？标记当前 nums\[i\] 存储的数字，是不是重新排列后的正确数字。如果是，存负数；如果不是，存正数（即原本的数字，还需处理）。

我们每次处理一个 nums\[i\]，计算这个 nums\[i\] 应该放置的正确位置 j。但是，nums\[j\] 还没有排列好，所以我们暂时把 nums\[j\] 放到 nums\[i\] 的位置上来，并且记录上，此时 nums\[i\] 的元素本来的索引是 j。现在，我们就可以安心地把 nums\[i\] 放到 j 的位置了。同时，因为这已经是 nums\[i\] 正确的位置，取负数，即标记这个位置已经存放了正确的元素。

之后，我们继续处理当前的 nums\[i\]，注意，此时这个新的 nums\[i\]，本来的索引是 j。所以我们根据 j 算出它应该存放的位置，然后把这个位置的元素放到 nums\[i\] 中，取负做标记。

这个过程以此类推。这就是代码中 `while` 循环做的事情。

直到 nums\[i\] 的值也是负数，说明 i 的位置也已经是重新排列后的正确元素了，我们就可以看下一个位置了。

在 `for` 循环中，如果某一个元素已经是小于零了，说明这个位置已经是正确元素了，可以忽略。

这个算法虽然有两重循环，但是时间复杂度是 O(n) 的，因为每个元素最多会被重新排列一次，然后会被最外面的 for 循环访问一次。一旦重新排列过，for 的访问只是一次 `if` 判断而已。

当然，最后，数组中的所有元素还需要从负数转换回正数。

我的参考代码（C++）：

```
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {

        for(int i = 0; i < 2 * n; i ++)
            if(nums[i] > 0){
                
                // j 描述当前的 nums[i] 对应的索引，初始为 i
                int j = i; 

                while(nums[i] > 0){

                    // 计算 j 索引的元素，也就是现在的 nums[i]，应该放置的索引
                    j = j < n ? 2 * j : 2 * (j - n) + 1; 

                    // 把 nums[i] 放置到 j 的位置，
                    // 同时，把 nums[j] 放到 i 的位置，在下一轮循环继续处理
                    swap(nums[i], nums[j]); 

                    // 使用负号标记上，现在 j 位置存储的元素已经是正确的元素了 
                    nums[j] = -nums[j]; 
                }
            }

        for(int& e: nums) e = -e;
        return nums;
    }
};

```
