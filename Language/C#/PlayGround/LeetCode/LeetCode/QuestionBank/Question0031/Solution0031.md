#### 下一个排列

本质上就是数据的局部排序问题，即数组的排序问题。

##### 下面用一个示例简单分析一下

假设有数组的$[1, 2, 3, 4]$，下面一次分析数组的下一个排列。

- 初始状态：$[1, 2, 3, 4]$
- 下一个排列：$[1, 2, 4, 3]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[1, 2, 4, 3]$
- 下一个排列：$[1, 3, 2, 4]$
    - 检查数组的最后2位已经是倒序了，将检查范围扩大到3位，从最后2位中找到（二分法）第一个大于倒数第3位的元素，然后二者互换位置，得到$[1, 3, 4, 2]$
    - 将数组的最后2位排序得到下一个排列：$[1, 3, 2, 4]$
- 下一个排列：$[1, 3, 4, 2]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[1, 3, 4, 2]$
- 下一个排列：$[1, 4, 2, 3]$
    - 检查数组的最后2位已经是倒序了，将检查范围扩大到3位，从最后2位中找到（二分法）第一个大于倒数第3位的元素，然后二者互换位置，得到$[1, 4, 3, 2]$
    - 将数组的最后2位排序得到下一个排列：$[1, 4, 2, 3]$
- 下一个排列：$[1, 4, 3, 2]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[1, 4, 3, 2]$
- 下一个排列：$[2, 1, 3, 4]$
    - 检查数组的最后2位已经是倒序了，将检查范围扩大到3位，最后3位依然逆序，将检查范围扩大到4位，从最后3位中找到（二分法）第一个大于倒数第4位的元素，然后二者互换位置，得到$[2, 4, 3, 1]$
    - 将数组的最后3位排序得到下一个排列：$[2, 1, 3, 4]$
- 下一个排列：$[2, 1, 4, 3]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[2, 1, 4, 3]$
- 下一个排列：$[2, 3, 1, 4]$
    - 检查数组的最后2位已经是倒序了，将检查范围扩大到3位，从最后2位中找到（二分法）第一个大于倒数第3位的元素，然后二者互换位置，得到$[2, 3, 4, 1]$
    - 将数组的最后2位排序得到下一个排列：$[2, 3, 1, 4]$
- 下一个排列：$[2, 3, 4, 1]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[2, 3, 4, 1]$
- 下一个排列：$[2, 4, 1, 3]$
    - 检查数组的最后2位已经是倒序了，将检查范围扩大到3位，从最后2位中找到（二分法）第一个大于倒数第3位的元素，然后二者互换位置，得到$[2, 4, 3, 1]$
    - 将数组的最后2位排序得到下一个排列：$[2, 4, 1, 3]$
- 下一个排列：$[2, 4, 3, 1]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[2, 4, 3, 1]$
- 下一个排列：$[3, 1, 2, 4]$
    - 检查数组的最后2位已经是倒序了，将检查范围扩大到3位，最后3位依然逆序，将检查范围扩大到4位，从最后3位中找到（二分法）第一个大于倒数第4位的元素，然后二者互换位置，得到$[3, 4, 2, 1]$
    - 将数组的最后3位排序得到下一个排列：$[3, 1, 2, 4]$
- 下一个排列：$[3, 1, 4, 2]$
    - 检查数组的最后2位，是正序的，所以将最后2位元素互换得到下一个排列：$[3, 1, 4, 2]$
- $\dots \enspace \dots$

##### 几点优化

1. 只有在最后$n$位完全倒序的情况下才需要将范围扩大到$n+1$位，所以检查$n+1$位是否是倒序时，只要比较第$n$位与第$n+1$位即可；
2. 在最后$n$位中找最小的大于n的元素时，可以使用二分法，因为最后$n$位是严格倒序的，而且一定有解，否则范围就需要继续扩大了；
3. 在将第$n+1$位第$k$位交换后，数组的最后$n$位仍然是倒序的，所以不需要使用排序算法去做数组的局部排序，只需将数组的这部分反转即可；
