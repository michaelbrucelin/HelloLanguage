using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace TestCSharp
{
    class Program
    {
        static void Main(string[] args)
        {
            Func<long> func = DoSomethingLong;
            IAsyncResult asyncResult = func.BeginInvoke(null, null);  // 这个异步调用结果，是用来描述异步操作的

            // 现在做另一件事
            Enumerable.Range(1, 8).ToList().ForEach(i =>  // 将8改为32再试一次，或者64，只要保证同步线程比子线程慢即可
            {
                Thread.Sleep(100);
                Console.WriteLine($"{i}... ...");
            });

            long result = func.EndInvoke(asyncResult);  // 获取异步操作的真实返回值，这里会阻塞，直到拿到子线程的结果为止
            Console.WriteLine($"执行结果为：{result}");

            Console.ReadKey();
        }

        private static long DoSomethingLong()
        {
            long lResult = 0;
            for (int i = 0; i < 1000000000; i++)
            {
                lResult += i;
            }

            return lResult;
        }
    }
}

/*
获取子线程的结果
至于结果的输出过程，在输出完"8... ..."后，等待了一会才输出子线程的结果，证明这里是等待子线程运行的。
而当把同步任务中的8改为32后，发现，在输出完"32... ..."后，立刻输出了子线程的结果，说明子线程的确是异步执行的。

同步任务是8时的输出结果
1... ...
2... ...
3... ...
4... ...
5... ...
6... ...
7... ...
8... ...
执行结果为：499999999500000000

同步任务中的8改为32的输出
1... ...
2... ...
3... ...
4... ...
5... ...
6... ...
7... ...
8... ...
9... ...
10... ...
11... ...
12... ...
13... ...
14... ...
15... ...
16... ...
17... ...
18... ...
19... ...
20... ...
21... ...
22... ...
23... ...
24... ...
25... ...
26... ...
27... ...
28... ...
29... ...
30... ...
31... ...
32... ...
执行结果为：499999999500000000
*/